use std::any::type_name;
use serde::{Serialize, Deserialize};
use once_cell::sync::Lazy;


/// Partial implementation of [ReactiveMessagingTextualSerializer<>] able to serialize `LocalMessages` in a text with the `ron` crate
pub trait ReactiveMessagingRonSerializer<LocalMessages> {

    // NOTE: the methods in this trait are a copy of the ones in `ReactiveMessagingBinarySerializer`
    //       -- please, keep them in sync

    /// Called whenever the local processor found an error -- such as "we are too busy to process your request at the moment".
    /// If any, the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn processor_error_message(_err: String) -> Option<LocalMessages> {
        // By default, we do not inform the peer if a local error occurred.
        // However, implementors are encouraged to do so.
        None
    }

    /// Called when the local processor couldn't understand the received message.
    /// If any, the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn parsing_error_message(_err: String) -> Option<LocalMessages> {
        // By default, we do not inform the peer if they sent a bad message.
        // However, implementors are encouraged to do so.
        None
    }

}
impl<T, LocalMessages> ReactiveMessagingTextualSerializer<LocalMessages> for T
where
    T:             ReactiveMessagingRonSerializer<LocalMessages>,
    LocalMessages: Serialize {

    #[inline(always)]
    fn serialize(local_message: &LocalMessages, buffer: &mut Vec<u8>) {
        ron_serializer(local_message, buffer)
            .unwrap_or_else(|err| panic!("`reactive_messaging::ReactiveMessagingRonSerializer<{}>::serialize()` Failed to serialize with RON: {err}",
                                                                type_name::<LocalMessages>()))
    }

    #[inline(always)]
    fn processor_error_message(err: String) -> Option<LocalMessages> {
        T::processor_error_message(err)
    }

    #[inline(always)]
    fn parsing_error_message(err: String) -> Option<LocalMessages> {
        T::parsing_error_message(err)
    }
}

/// Partial implementation of [ReactiveMessagingTextualDeserializer<>] able to deserialize a `ron` textual String back into `RemoteMessages`
pub trait ReactiveMessagingRonDeserializer<RemoteMessages: for<'r> Deserialize<'r>> {}
impl<T, RemoteMessages> ReactiveMessagingTextualDeserializer<RemoteMessages> for T
where
    T:              ReactiveMessagingRonDeserializer<RemoteMessages>,
    RemoteMessages: for<'r> Deserialize<'r> {

    #[inline(always)]
    fn deserialize(remote_message: &[u8]) -> Result<RemoteMessages, Box<dyn std::error::Error + Sync + Send>> {
        ron_deserializer(remote_message)
            .map_err(|err| Box::from(format!("`reactive_messaging::ReactiveMessagingRonDeserializer<{}>::deserialize()` Failed to deserialize with RON: {err}",
                                                                          type_name::<RemoteMessages>())))

    }
}

/// NOTE: Users of this crate are likely not to want to use this trait directly. See, instead: [ReactiveMessagingRonSerializer<>].
///
/// Trait that should be implemented by enums that model the "local messages" to be sent to the remote peer --
/// "local messages" may either be messages generated by the server or by the client, depending on if you're building a server or client.\
/// This trait, therefore, specifies how to:
///   * `serialize()` enum variants into a String (like RON) to be sent to the remote peer
///   * inform the peer if any wrong input was sent -- the network processor will handle that special case.
pub trait ReactiveMessagingTextualSerializer<LocalMessages> {

    /// Local messages serializer: transforms a strong typed `local_message` into a sequence of bytes, putting it in `buffer`.\
    /// IMPLEMENTORS: #[inline(always)]
    fn serialize(local_message: &LocalMessages, buffer: &mut Vec<u8>);

    /// Called whenever the local processor found an error -- such as "we are too busy to process your request at the moment".
    /// If any, the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn processor_error_message(err: String) -> Option<LocalMessages>;

    /// Called when the local processor couldn't understand the received message.
    /// If any, the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn parsing_error_message(err: String) -> Option<LocalMessages>;
}

/// NOTE: Users of this crate are likely not to want to use this trait directly. See, instead: [ReactiveMessagingRonDeserializer<>]

/// Trait that should be implemented by enums that model the remote messages" to be consumed by a "Responsive Processor" --
/// "remote messages" may either be messages produced by the remote server or by the remote client (when we are implementing the opposite peer).
/// 
/// This trait, therefore, specifies how to `deserialize()` enum variants received by the remote peer (like RON).
pub trait ReactiveMessagingTextualDeserializer<RemoteMessages> {

    /// Remote messages deserializer: transform the textual-serialized `remote_message` into a `RemoteMessages` value.\
    /// IMPLEMENTORS: #[inline(always)]
    fn deserialize(remote_message: &[u8]) -> Result<RemoteMessages, Box<dyn std::error::Error + Sync + Send>>;

}


// RON SERDE
////////////

static RON_DESERIALIZER_CONFIG: Lazy<ron::Options> = Lazy::new(ron::Options::default);

/// RON serializer
#[inline(always)]
fn ron_serializer<T: ?Sized + Serialize>(message: &T, buffer: &mut Vec<u8>) -> Result<(), ron::Error> {

    use std::fmt::{self, Write};
    pub struct VecWriteAdapter<'a>(&'a mut Vec<u8>);
    impl Write for VecWriteAdapter<'_> {
        fn write_str(&mut self, s: &str) -> fmt::Result {
            self.0.extend_from_slice(s.as_bytes());
            Ok(())
        }
    }

    buffer.clear();
    let buffer = VecWriteAdapter(buffer);
    let mut serializer = ron::Serializer::with_options(buffer, None, &RON_DESERIALIZER_CONFIG)?;
    message.serialize(&mut serializer)?;
    Ok(())
}

/// RON deserializer
#[inline(always)]
fn ron_deserializer<T: for<'r> Deserialize<'r>>(message: &[u8]) -> Result<T, Box<dyn std::error::Error + Sync + Send>> {
    RON_DESERIALIZER_CONFIG.from_bytes(message)
        .map_err(|err| Box::from(format!("RON deserialization error for message '{:?}': {}", std::str::from_utf8(message), err)))
}


/// Unit tests for our socket server [serde](self) module
#[cfg(any(test,doc))]
mod tests {
    use super::*;


    /// assures RON serialization / deserialization works for all client / server messages
    #[cfg_attr(not(doc),test)]
    fn ron_serde_for_server_only() {

        #[derive(Debug, PartialEq, Serialize, Deserialize)]
        pub enum Messages {
            Echo(String),
            Recursive(Option<Box<Messages>>)
        }

        let mut buffer = Vec::<u8>::with_capacity(64);
        let message = Messages::Echo(String::from("This is an error message"));
        let expected = "Echo(\"This is an error message\")";
        ron_serializer(&message, &mut buffer).expect("calling `ron_serializer()`");
        let observed = String::from_utf8(buffer).expect("Ron should be utf-8");
        assert_eq!(observed, expected, "RON serialization is not good");

        let message = "Recursive(Some(Recursive(Some(Echo(\"here it is\")))))".as_bytes();
        let expected = Messages::Recursive(Some(Box::new(Messages::Recursive(Some(Box::new(Messages::Echo(String::from("here it is"))))))));
        let observed = ron_deserializer::<Messages>(message)
            .expect("RON deserialization failed");
        assert_eq!(observed, expected, "RON deserialization is not good");
    }
}