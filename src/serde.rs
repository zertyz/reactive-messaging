//! SERializers & DEserializers (traits & implementations) for our [SocketServer]


use std::fmt::Debug;
use serde::{Serialize, Deserialize};
use once_cell::sync::Lazy;

/// Structs or Enums that implement this trait declares they can be serialized/deserialized
/// "as-is" in binary form. This leads to the best possible performance when compared to
/// the alternatives (to implement both [ReactiveMessagingSerializer] & [ReactiveMessagingDeserializer]).\
/// Usually, types that use only primitive types (such as the numbers, char, sub-types consisting only of
/// those, and arrays of those types) are safe to implement this trait. Note, however, that no endian,
/// floating point, nor any other conversions are made.\
/// An important property that arise from all that was exposed is that each payload has, inevitably,
/// a fixed size.\
/// IMPORTANT: implementing this trait for a type that is not memory mappable will lead to program crashing.
///            In the future, a proc-macro may be used to implement this trait while ensuring these constraints
///            and, specially, verifying that all subtypes also implement this trait properly.
/// CRITICALLY IMPORTANT: until the proc-macro is ready, bad use of this trait may break your program:
///                       example: you have a complex model with several reusable subtypes. Over time, a jr. Engineer
///                       add a new enum variant with a String field, unaware of this issue.
///                       Implications:
///                         1) The program will not break at first. Only when the new variant (with the new field) is used
///                            -- creating a "really hard to track" error;
///                         2) Any unit tests you may have written will not fail because of this new variant/field
///                            -- it would be required the jr. Engineer would write a test with their new variant/field
///                               so the serde error could be exposed;
///                         3) Nonetheless, even with these current limitations, proper code reviews and presence of
///                            automated tests can effectively block any issues from making it to production;
///                         4) This problem will be short-lived: issue **(n12)** will soon take care of it for good.
pub trait ReactiveMessagingMemoryMappable: PartialEq + Debug {}

/// Trait that should be implemented by enums that model the "local messages" to be sent to the remote peer --
/// "local messages" may either be messages generated by the server or by the client, depending on if you're building a server or client.\
/// This trait, therefore, specifies how to:
///   * `serialize()` enum variants into a binary blob (possibly through RKYV) to be sent to the remote peer
///   * if input validation is implemented, inform the peer if any wrong input was sent -- the network processor will handle that special case.
pub trait ReactiveMessagingBinarySerializer<LocalMessages> {

    /// Local messages serializer: transforms a strong typed `local_message` into a sequence of bytes, putting it in `buffer`.\
    /// IMPLEMENTORS: #[inline(always)]
    fn serialize(local_message: &LocalMessages, buffer: &mut Vec<u8>);

    /// Called whenever the local processor found an error -- the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn processor_error_message(err: String) -> LocalMessages;
}

/// Trait that should be implemented by enums that model the "remote messages" to be consumed by a "Responsive Processor" --
/// "remote messages" may either be messages produced by the remote server or by the remote client (when we are implementing the opposite peer).\
/// This trait, therefore, specifies how to `deserialize()` enum variants received by the remote peer (possibly through RKYV).
pub trait ReactiveMessagingBinaryDeserializer<RemoteMessages> {
    
    /// This is a version of `RemoteMessages` after it is deserialized.
    /// Needed by some safe zero-copy deserializers such as `rkyv`
    /// NOTE: to satisfy this condition, use '#[archive_attr(derive(Debug))]' in your type */
    type DeserializedRemoteMessages: Debug;

    /// Verifies if applying the [Self::deserialize()] on `remote_message` will produce valid results.\
    /// IMPLEMENTORS: #[inline(always)]
    fn validate(remote_message: &[u8]) -> Result<(), ()>;

    /// Remote messages deserializer: transforms the binary-serialized `remote_message` into a reference valid as long as the given buffer.\
    /// IMPLEMENTORS: #[inline(always)]
    fn deserialize(remote_message: &[u8]) -> &Self::DeserializedRemoteMessages;

}

/// Trait that should be implemented by enums that model the "local messages" to be sent to the remote peer --
/// "local messages" may either be messages generated by the server or by the client, depending on if you're building a server or client.\
/// This trait, therefore, specifies how to:
///   * `serialize()` enum variants into a String (like RON, for textual protocols) to be sent to the remote peer
///   * inform the peer if any wrong input was sent -- the network processor will handle that special case.
pub trait ReactiveMessagingSerializer<LocalMessages> {

    /// Local messages serializer: transforms a strong typed `local_message` into a sequence of bytes, putting it in `buffer`.\
    /// IMPLEMENTORS: #[inline(always)]
    fn serialize_textual(local_message: &LocalMessages, buffer: &mut Vec<u8>);

    /// Called whenever the local processor found an error -- the returned message (enum variant) should be as descriptive as possible,
    /// as it will be sent in response to the remote party.\
    /// IMPLEMENTORS: #[inline(always)]
    fn processor_error_message(err: String) -> LocalMessages;
}

/// Trait that should be implemented by enums that model the "remote messages" to be consumed by a "Responsive Processor" --
/// "remote messages" may either be messages produced by the remote server or by the remote client (when we are implementing the opposite peer).\
/// This trait, therefore, specifies how to `deserialize()` enum variants received by the remote peer (like RON, for textual protocols).
pub trait ReactiveMessagingDeserializer<RemoteMessages> {

    /// Remote messages deserializer: transform the textual-serialized `remote_message` into a `RemoteMessages` value.\
    /// IMPLEMENTORS: #[inline(always)]
    fn deserialize_textual(remote_message: &[u8]) -> Result<RemoteMessages, Box<dyn std::error::Error + Sync + Send>>;

}


// RON SERDE
////////////

static RON_DESERIALIZER_CONFIG: Lazy<ron::Options> = Lazy::new(ron::Options::default);

/// RON serializer
#[inline(always)]
pub fn ron_serializer<T: ?Sized + Serialize>(message: &T, buffer: &mut Vec<u8>) -> Result<(), ron::Error> {

    use std::fmt::{self, Write};
    pub struct VecWriteAdapter<'a>(&'a mut Vec<u8>);
    impl<'a> Write for VecWriteAdapter<'a> {
        fn write_str(&mut self, s: &str) -> fmt::Result {
            self.0.extend_from_slice(s.as_bytes());
            Ok(())
        }
    }
    
    buffer.clear();
    let buffer = VecWriteAdapter(buffer);
    let mut serializer = ron::Serializer::with_options(buffer, None, &ron::Options::default())?;
    message.serialize(&mut serializer)?;
    Ok(())
}

/// RON deserializer
#[inline(always)]
pub fn ron_deserializer<T: for<'r> Deserialize<'r>>(message: &[u8]) -> Result<T, Box<dyn std::error::Error + Sync + Send>> {
    RON_DESERIALIZER_CONFIG.from_bytes(message)
        .map_err(|err| Box::from(format!("RON deserialization error for message '{:?}': {}", std::str::from_utf8(message), err)))
}


// RKYV SERDE
/////////////

use rkyv::{
    archived_root,
    ser::Serializer as RkyvSerializer,
};
use rkyv::ser::serializers::WriteSerializer;

/// RKYV serializer
#[inline(always)]
pub fn rkyv_serializer<'a, T: rkyv::Archive + rkyv::Serialize<WriteSerializer<&'a mut Vec<u8>>>>
                      (message: &'a T,
                       buffer: &'a mut Vec<u8>)
                      -> Result<(), Box<dyn std::error::Error + Sync + Send>> {
    buffer.clear();
    let mut serializer = WriteSerializer::new(buffer);
    serializer.serialize_value(message)?;
    Ok(())

    /*

DISCUSSIONS WITH AI:

1. Is this the fastest possible implementation?
Short Answer:
Not quite — there are marginal speed-ups possible by using a custom serializer that writes directly to a &mut [u8] or even statically allocated memory, and by turning off validation entirely in deserialization.
But what you’ve got is already very fast and zero-allocation (during reuse).
Details:
WriteSerializer<Vec<u8>> is almost optimal for dynamic memory.
However, if you know your maximum message size, you can use:
WriteSerializer<AlignedVec> for alignment guarantees and reuse.
WriteSerializer<&mut [u8]> for in-place serialization (fastest when you manage the buffer lifetime).
Removing validation (see Q3) gets you extra speed on deserialization, at the cost of possible memory corruption or undefined behavior.

-----------------------------

WriteSerializer<Vec<u8>>
Writes into an existing Vec<u8> (or &mut [u8]), without allocations if reused.
Very fast. Memory is reused.
Use when: performance matters, and you control the buffer.

WriteSerializer<AlignedVec>
Like above, but guarantees alignment (16- or 64-bit).
Safer if the target archive type has alignment-sensitive fields.
Slightly slower due to alignment overhead.
Use when: performance matters and you're working with types that have large alignment requirements (e.g., SIMD types).

*/

}

/// RKYV deserializer
#[inline(always)]
pub fn rkyv_deserializer<'a, T: rkyv::Archive>
                        (message: &'a [u8])
                        -> Result<&'a <T as rkyv::Archive>::Archived, Box<dyn std::error::Error + Sync + Send>> {
    let result = unsafe {
        archived_root::<T>(message)
    };
    Ok(result)
    
    /*
    
    DISCUSSIONS WITH AI:
    
    -- it gave me wrong information regarding how to turn on and off validation.
       This question will have to be asked again.
       PS: the above seems to make no validations at all.
    
    */
}


/// Unit tests for our socket server [serde](self) module
#[cfg(any(test,doc))]
mod tests {
    use super::*;

    
    /// assures RON serialization / deserialization works for all client / server messages
    #[cfg_attr(not(doc),test)]
    fn ron_serde_for_server_only() {

        #[derive(Debug, PartialEq, Serialize, Deserialize)]
        pub enum Messages {
            Echo(String),
            Recursive(Option<Box<Messages>>)
        }

        let mut buffer = Vec::<u8>::with_capacity(64);
        let message = Messages::Echo(String::from("This is an error message"));
        let expected = "Echo(\"This is an error message\")";
        ron_serializer(&message, &mut buffer).expect("calling `ron_serializer()`");
        let observed = String::from_utf8(buffer).expect("Ron should be utf-8");
        assert_eq!(observed, expected, "RON serialization is not good");

        let message = "Recursive(Some(Recursive(Some(Echo(\"here it is\")))))".as_bytes();
        let expected = Messages::Recursive(Some(Box::new(Messages::Recursive(Some(Box::new(Messages::Echo(String::from("here it is"))))))));
        let observed = ron_deserializer::<Messages>(message)
            .expect("RON deserialization failed");
        assert_eq!(observed, expected, "RON deserialization is not good");
    }

    /// assures RKYV serialization / deserialization works for all client / server messages
    #[cfg_attr(not(doc),test)]
    fn rkyv_serde_for_server_only() {

        #[derive(Clone, Debug, PartialEq, rkyv::Serialize, rkyv::Deserialize, rkyv::Archive)]
        pub enum Messages {
            Echo(String),
            TheEnd
        }

        let mut buffer = Vec::<u8>::with_capacity(64);
        let expected_value = String::from("This is a message tha will go through RKYV");
        let message = Messages::Echo(expected_value.clone());
        rkyv_serializer(&message, &mut buffer).expect("calling `rkyv_serializer()`");
        let observed = rkyv_deserializer::<Messages>(&buffer).expect("RKYV deserialization failed");
        // assert
        if let ArchivedMessages::Echo(observed_value) = observed {
            assert_eq!(observed_value.as_str(), expected_value.as_str(), "RKYV serialization is not looking good");
        } else {
            panic!("RON serialization failed -- the variant is wrong");
        }
    }
}